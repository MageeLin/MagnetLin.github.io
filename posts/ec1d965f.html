<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/bangchui-32x32-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/bangchui-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/bangchui-16x16-next.png">
  <link rel="mask-icon" href="/images/bangchui-logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://linjingyi.cn').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="今天在知乎看到了一个回答说李松峰老师已经神速的把 1000 多页翻译完了，有三名编辑负责交接。太振奋了，英文版实在看的头有点疼，自己翻译自己看的日子终于快到头了，一定要买到首发第一批！ 在 Map 和 Set 章节发现了多处错误，已更正。 下述内容翻译自 Professional JavaScript for Web Developes,4th Edition（JavaScript 高级程序设计第">
<meta property="og:type" content="article">
<meta property="og:title" content="JS高程第4版新增章节翻译：类型化数组、Map和Set">
<meta property="og:url" content="https://linjingyi.cn/posts/ec1d965f.html">
<meta property="og:site_name" content="林景宜的记事本">
<meta property="og:description" content="今天在知乎看到了一个回答说李松峰老师已经神速的把 1000 多页翻译完了，有三名编辑负责交接。太振奋了，英文版实在看的头有点疼，自己翻译自己看的日子终于快到头了，一定要买到首发第一批！ 在 Map 和 Set 章节发现了多处错误，已更正。 下述内容翻译自 Professional JavaScript for Web Developes,4th Edition（JavaScript 高级程序设计第">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-04-30T12:30:47.000Z">
<meta property="article:modified_time" content="2020-04-30T12:30:47.000Z">
<meta property="article:author" content="林景宜">
<meta property="article:tag" content="翻译">
<meta property="article:tag" content="JS">
<meta property="article:tag" content="JS高程">
<meta property="article:tag" content="红宝书">
<meta property="article:tag" content="JavaScript高级程序设计">
<meta property="article:tag" content="第4版">
<meta property="article:tag" content="Typed Arrays">
<meta property="article:tag" content="Map">
<meta property="article:tag" content="Set">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://linjingyi.cn/posts/ec1d965f.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>JS高程第4版新增章节翻译：类型化数组、Map和Set | 林景宜的记事本</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e7bf681a68fc68b663d40333164a4df9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">林景宜的记事本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">爱囡囡，最无双</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://linjingyi.cn/posts/ec1d965f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/bangchui-logo.svg">
      <meta itemprop="name" content="林景宜">
      <meta itemprop="description" content="一个已婚的前端er">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林景宜的记事本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          JS高程第4版新增章节翻译：类型化数组、Map和Set
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-30 20:30:47" itemprop="dateCreated datePublished" datetime="2020-04-30T20:30:47+08:00">2020-04-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/JS/%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>今天在知乎看到了一个回答说李松峰老师已经神速的把 1000 多页翻译完了，有三名编辑负责交接。太振奋了，英文版实在看的头有点疼，自己翻译自己看的日子终于快到头了，一定要买到首发第一批！</p>
<p>在 Map 和 Set 章节发现了多处错误，已更正。</p>
<p>下述内容翻译自 Professional JavaScript for Web Developes,4th Edition（<a href="https://www.ituring.com.cn/book/2472" target="_blank" rel="external nofollow noopener noreferrer">JavaScript 高级程序设计第四版</a>），190 页，COLLECTION REFERENCE TYPES 章节内，前半部分是普通 Array 的介绍，已经比较熟悉，主要翻译后半部分——类型化数组、Map 和 Set。</p>
<a id="more"></a>

<h3 id="类型化数组"><a href="#类型化数组" class="headerlink" title="类型化数组"></a>类型化数组</h3><p>在 ECMAScript6 中，类型化数组（TYPED ARRAYS）是一种设计用于向本地库高效传递二进制数据的结构。JavaScript 中并没有真正的“TypedArray”类型，相反，这个术语指的是一组包含数字类型的特殊数组。想要理解如何使用类型化数组，首先需要理解它的用途。</p>
<h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><p>随着 web 浏览器的普及，可以预见在浏览器内部运行复杂的 3D 应用的能力将会大受欢迎。早在 2006 年，包括 Mozilla 和 Opera 在内的浏览器厂商就开始试验一种编程平台，用于在浏览器内部无需插件就可渲染图形密集型应用。目标是开发一个 JavaScript API，可以利用 3D 图形 API 和 GPU 加速来实现在<code>&lt;canvas&gt;</code>元素上渲染复杂图形。</p>
<h5 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h5><p>最终实现的 JavaScript API 是基于 OpenGL for Embedded Systems（OpenGL ES）2.0 规范，该规范是 OpenGL 的一个子集，专门用于实现 2D 和 3D 计算机图形。这个新的 API 被命名为 Web Graphics Library（WebGL），在 2011 年 3 月发布了它的 1.0 版本。有了该 API，开发者就能够编写图形密集型的应用程序代码，这些代码可以被任何兼容 WebGL 的 web 浏览器原生地编译。</p>
<p>在 WebGL 的初始版本中，JavaScript 数组和原生数组之间的不匹配导致出现了性能问题。图形驱动的 API 通常不希望传递的数组内容是 JavaScript 默认的双浮点格式。图形驱动的 API 期望以二进制格式的数字数组格式传递，这当然与内存中的 JavaScript 数组格式不同。因此，每次在 WebGL 和 JavaScript 运行时之间传递一个数组时，WebGL 都会执行一个浪费性能的操作，即在目标环境中分配一个新数组，把当前数组的数字转换为适当的格式迭代给新数组。</p>
<h5 id="类型化数组的出现"><a href="#类型化数组的出现" class="headerlink" title="类型化数组的出现"></a>类型化数组的出现</h5><p>当然，上述转换操作是不合适的，Mozilla 通过实现 CanvasFloatArray 解决了这个问题，这是一个 C 语言风格的浮点数数组，提供了一个 JavaScript 接口。这种类型允许 JavaScript 运行时分配、读取和写入一个数组，该数组可以直接传递给图形驱动程序的 API。Canvasfloatarray 最终将被重塑为 Float32Array，这是目前类型化数组可用的第一个“类型”。</p>
<h4 id="使用-ArrayBuffers"><a href="#使用-ArrayBuffers" class="headerlink" title="使用 ArrayBuffers"></a>使用 ArrayBuffers</h4><p>Float32array 实际上是一种“视图（view）”类型，该类型允许 JavaScript 运行时访问一块分配好的内存，称为 ArrayBuffer。Arraybuffer 是所有类型化数组和视图引用的基本单元。</p>
<blockquote>
<p>Typedarraybuffer 是 ArrayBuffer 类型的一个变体，该变体可以在执行上下文环境之间传递而不生成副本。有关该类型的内容，请参阅“Workers”一章。</p>
</blockquote>
<p>Arraybuffer 是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>); <span class="comment">// 分配16字节的内存</span></span><br><span class="line">alert(buf.byteLength); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<p>数组缓冲区（Arraybuffer）一旦创建就不能调整大小。但是可以使用 slice()将现有 ArrayBuffer 的全部或部分复制到新实例中:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf1 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">const</span> buf2 = buf1.slice(<span class="number">4</span>, <span class="number">12</span>);</span><br><span class="line">alert(buf2.byteLength); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>Arraybuffer 在某些方面类似于 c++malloc()，但有几个不同的地方值得注意:</p>
<ul>
<li>当 malloc()分配失败时，它返回一个空指针，如果 ArrayBuffer 分配失败，它抛出一个 error。</li>
<li>malloc()调用可以使用虚拟内存，因此最大的内存分配只受可寻址的系统内存大小限制。Arraybuffer 的内存分配不能超过 Number.MAXSAFEINTEGER(2^53)字节。</li>
<li>成功的 malloc()调用不初始化实际地址。声明一个 ArrayBuffer 将所有位初始化为 0。</li>
<li>在调用 free()或程序退出之前，系统不能使用 malloc()分配的堆内存。通过声明一个 ArrayBuffer 分配的堆内存仍然是可垃圾回收的ー不需要进行手动内存管理。</li>
</ul>
<p>不能通过引用缓冲区（buffer）实例来读取或写入 ArrayBuffer 的内容。若要在内部读取或写入数据，必须使用视图（view）。有多种不同类型的视图，但它们都引用存储在 ArrayBuffer 中的二进制数据。</p>
<h4 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h4><p>允许读写 ArrayBuffer 的第一种视图类型是 DataView。这个视图是为文件和网络 I/O 设计的；该 API 允许高度自由控制 buffer 数据的操作，但是与其他不同的视图类型相比，该类型的性能比较低。Dataview 不预设任何关于缓冲区的内容，也不可迭代。</p>
<p>读取和写入已经存在的 ArrayBuffer 时必须创建一个 DataView 实例。它可以使用整个或部分 buffer，并维护对 buffer 实例的引用，以及设定视图在 buffer 中的开始位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// DataView默认使用全部的ArrayBuffer</span></span><br><span class="line"><span class="keyword">const</span> fullDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line">alert(fullDataView.byteOffset); <span class="comment">// 0</span></span><br><span class="line">alert(fullDataView.byteLength); <span class="comment">// 16</span></span><br><span class="line">alert(fullDataView.buffer === buf); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 构造函数中有两个可选参数：字节偏移和字节长度</span></span><br><span class="line"><span class="comment">// byteOffset=0 视图从buffer的起始位置开始</span></span><br><span class="line"><span class="comment">// byteLength=8 限制视图为前8个字节</span></span><br><span class="line"><span class="keyword">const</span> firstHalfDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">alert(firstHalfDataView.byteOffset); <span class="comment">// 0</span></span><br><span class="line">alert(firstHalfDataView.byteLength); <span class="comment">// 8</span></span><br><span class="line">alert(firstHalfDataView.buffer === buf); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 如果不指定长度的话，DataView将会使用buffer的剩余部分</span></span><br><span class="line"><span class="comment">// byteOffset=8 视图从buffer的第9位开始</span></span><br><span class="line"><span class="comment">// byteLength默认时剩余buffer的长度</span></span><br><span class="line"><span class="keyword">const</span> secondHalfDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf, <span class="number">8</span>);</span><br><span class="line">alert(secondHalfDataView.byteOffset); <span class="comment">// 8</span></span><br><span class="line">alert(secondHalfDataView.byteLength); <span class="comment">// 8</span></span><br><span class="line">alert(secondHalfDataView.buffer === buf); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>要通过 DataView 读写缓冲区，你需要使用以下几点内容:</p>
<ul>
<li>要读或写位置的字节偏移量。这可以看作是 DataView 中的一种“地址”。</li>
<li>DataView 应使用 ElementType 在 JavaScript 运行时中的 Number 类型和缓冲区中的二进制格式之间进行转换。</li>
<li>内存中值的端序（endianness）。默认为 大端（big-endian）。</li>
</ul>
<h5 id="ElementType"><a href="#ElementType" class="headerlink" title="ElementType"></a>ElementType</h5><p>Dataview 对缓冲区中存储的数据类型不做任何假设。API 在读写时强制指定 ElementType，然后 DataView 将全面转换以执行读写操作。</p>
<p>ECMAScript 6 支持 8 种不同的 ElementType:</p>
<table>
<thead>
<tr>
<th>ELEMENTTYPE</th>
<th>字节数</th>
<th>描述</th>
<th>C 语言对照</th>
<th>值范围</th>
</tr>
</thead>
<tbody><tr>
<td>Int8</td>
<td>1</td>
<td>8 位有符号整数</td>
<td>signed char</td>
<td>–128 到 127</td>
</tr>
<tr>
<td>Uint8</td>
<td>1</td>
<td>8 位无符号整数</td>
<td>unsigned char</td>
<td>0 到 255</td>
</tr>
<tr>
<td>Int16</td>
<td>2</td>
<td>16 位有符号整数</td>
<td>short</td>
<td>–32768 到 32767</td>
</tr>
<tr>
<td>Uint16</td>
<td>2</td>
<td>16 位无符号整数</td>
<td>unsigned short</td>
<td>0 到 65535</td>
</tr>
<tr>
<td>Int32</td>
<td>4</td>
<td>32 位有符号整数</td>
<td>int</td>
<td>–2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td>Uint32</td>
<td>4</td>
<td>32 位无符号整数</td>
<td>unsigned int</td>
<td>0 到 4,294,967,295</td>
</tr>
<tr>
<td>Float32</td>
<td>4</td>
<td>32 位 IEEE-754 浮点数</td>
<td>float</td>
<td>–3.4E+38 到 +3.4E+38</td>
</tr>
<tr>
<td>Float64</td>
<td>8</td>
<td>64 位 IEEE-754 浮点数</td>
<td>double</td>
<td>–1.7E+308 到 +1.7E+308</td>
</tr>
</tbody></table>
<p>Dataview 公开了每种类型的 get 和 set 方法，这些方法使用 byteOffset 在 buffer 中寻址以读取和写入值。类型是可以互换使用的，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配2字节的内存并声明一个DataView实例</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 证明整个buffer实际所有位都是0</span></span><br><span class="line"><span class="comment">// 检查第一个和第二个字节</span></span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line">alert(view.getInt8(<span class="number">1</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 检查整个buffer</span></span><br><span class="line">alert(view.getInt16(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 把整个buffer设成一个字节</span></span><br><span class="line"><span class="comment">// 255按位表示是11111111 (2^8 – 1)</span></span><br><span class="line">view.setUint8(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="comment">// DataView将会自动的把值转换为指定的ElementType类型</span></span><br><span class="line"><span class="comment">// 255在16进制中表示为0xFF</span></span><br><span class="line">view.setUint8(<span class="number">1</span>, <span class="number">0xff</span>);</span><br><span class="line"><span class="comment">// 现在是个两个字节的带符号整数，结果为-1</span></span><br><span class="line">alert(view.getInt16(<span class="number">0</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h5 id="大端和小端"><a href="#大端和小端" class="headerlink" title="大端和小端"></a>大端和小端</h5><p>在前一个示例中，buffer 的字节故意全都设为相同的，以避免端序问题。“端序（Endianness）”是指由计算系统维护的字节排序约定。对于 DataViews 只支持两个约定：大端（big-endian）和小端（little-endian）。大端(也称为“网络字节顺序”)意味着最高有效字节位于第一个字节，最低有效字节位于最后一个字节。Little-endian 意味着最低有效字节保存在第一个字节中，最高有效字节保存在最后一个字节中。</p>
<p>执行 JavaScript 运行时系统的原生端序将约定如何读取和写入字节，但 DataView 不遵守这个约定。Dataview 是一个无偏见的内存片段接口，遵循指定的任何端序。所有 DataView API 方法都默认大端，但接受一个可选的布尔参数，该参数允许通过将 little-endian 设置为 true 来启用小端模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配2字节的内存并声明一个DataView实例</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 把buffer的最左位和最右位设为1</span></span><br><span class="line">view.setUint8(<span class="number">0</span>, <span class="number">0x80</span>); <span class="comment">// 设置最左位为1</span></span><br><span class="line">view.setUint8(<span class="number">1</span>, <span class="number">0x01</span>); <span class="comment">// 设置最右位为1</span></span><br><span class="line"><span class="comment">// buffer内容（为了可读性而分隔开）:</span></span><br><span class="line"><span class="comment">// 0x8 0x0 0x0 0x1</span></span><br><span class="line"><span class="comment">// 1000 0000 0000 0001</span></span><br><span class="line"><span class="comment">// 按大端读取16位无符号整数</span></span><br><span class="line"><span class="comment">// 0x80是最高有效字节，0x01是最低有效字节</span></span><br><span class="line"><span class="comment">// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769</span></span><br><span class="line">alert(view.getUint16(<span class="number">0</span>)); <span class="comment">// 32769</span></span><br><span class="line"><span class="comment">// 按小端读取16位无符号整数</span></span><br><span class="line"><span class="comment">// 0x01是最高有效字节，0x80是最低有效字节</span></span><br><span class="line"><span class="comment">// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384</span></span><br><span class="line">alert(view.getUint16(<span class="number">0</span>, <span class="literal">true</span>)); <span class="comment">// 384</span></span><br><span class="line"><span class="comment">// 按大端写入16位无符号整数</span></span><br><span class="line">view.setUint16(<span class="number">0</span>, <span class="number">0x0004</span>);</span><br><span class="line"><span class="comment">// buffer内容（为了可读性而分隔开）:</span></span><br><span class="line"><span class="comment">// 0x0 0x0 0x0 0x4</span></span><br><span class="line"><span class="comment">// 0000 0000 0000 0100</span></span><br><span class="line">alert(view.getUint8(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line">alert(view.getUint8(<span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 按小端写入16位无符号整数</span></span><br><span class="line">view.setUint16(<span class="number">0</span>, <span class="number">0x0002</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// buffer内容（为了可读性而分隔开）:</span></span><br><span class="line"><span class="comment">// 0x0 0x2 0x0 0x0</span></span><br><span class="line"><span class="comment">// 0000 0010 0000 0000</span></span><br><span class="line">alert(view.getUint8(<span class="number">0</span>)); <span class="comment">// 2</span></span><br><span class="line">alert(view.getUint8(<span class="number">1</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h5 id="极端案例"><a href="#极端案例" class="headerlink" title="极端案例"></a>极端案例</h5><p>只有在有足够的 buffer 空间情况下，DataView 才能完成读写操作；否则会抛出一个 RangeError:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 部分越过了buffer后界时尝试读取值</span></span><br><span class="line">view.getInt32(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="comment">// 越过了buffer后界时尝试读取值</span></span><br><span class="line">view.getInt32(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="comment">// 越过了buffer后界时尝试读取值</span></span><br><span class="line">view.getInt32(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="comment">// 越过了buffer后界时尝试写入值</span></span><br><span class="line">view.setInt32(<span class="number">4</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure>

<p>当写入 buffer 时，DataView 将尽力将值强制转换为适当的类型或回退到 0。如果不能将抛出一个 error:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="number">1.5</span>);</span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 1</span></span><br><span class="line">view.setInt8(<span class="number">0</span>, [<span class="number">4</span>]);</span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 4</span></span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="string">'f'</span>);</span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="built_in">Symbol</span>());</span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h4 id="类型化数组-1"><a href="#类型化数组-1" class="headerlink" title="类型化数组"></a>类型化数组</h4><p>类型化数组（Typed arrays）是 ArrayBuffer 视图的另一种形式。虽然在概念上类似于数据视图（Data View），但类型化数组的不同之处在于强制使用单个 ElementType 类型 并服从系统的原生端序。优点是提供了更广泛的 API 和更好的性能。类型化数组的设计是为了高效地与 WebGL 这样的本地库交换二进制数据。因为类型化数组的二进制表示对于本地操作系统来说是一种易于理解的格式，所以 JavaScript 引擎能够对类型化数组的算术运算、位运算和其他常见操作进行大幅度优化，因此它们的使用速度非常快。</p>
<p>类型化数组可以使用多种方式创建：从现有的 buffer 读取、用自己的 buffer 初始化、用迭代器填充或从任何类型的现有类型化数组填充。它们也可以使用<code>&lt;ElementType&gt;.from()</code>和 <code>&lt;ElementType&gt;.of()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个12字节的buffer</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">12</span>);</span><br><span class="line"><span class="comment">// 引用buffer创建一个Int32Array类型化数组</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buf);</span><br><span class="line"><span class="comment">// 类型化数组能识别出每个元素需要4个字节，所以长度是3</span></span><br><span class="line">alert(ints.length); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 创建一个长度为6的Int32Array类型化数组</span></span><br><span class="line"><span class="keyword">const</span> ints2 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 每一个数字使用了4个字节，所以ArrayBuffer有24个字节</span></span><br><span class="line">alert(ints2.length); <span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 与DataView类似，类型化数组有一个相关buffer的引用</span></span><br><span class="line">alert(ints2.buffer.byteLength); <span class="comment">// 24</span></span><br><span class="line"><span class="comment">// 创建一个包含[2, 4, 6, 8]的Int32Array类型化数组</span></span><br><span class="line"><span class="keyword">const</span> ints3 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]);</span><br><span class="line">alert(ints3.length); <span class="comment">// 4</span></span><br><span class="line">alert(ints3.buffer.byteLength); <span class="comment">// 16</span></span><br><span class="line">alert(ints3[<span class="number">2</span>]); <span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 拷贝ints3创建一个Int16Array类型的类型化数组</span></span><br><span class="line"><span class="keyword">const</span> ints4 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(ints3);</span><br><span class="line"><span class="comment">// 新的类型化数组分配他自己的内存，相同下标处的值会转化为新的表达。</span></span><br><span class="line">alert(ints4.length); <span class="comment">// 4</span></span><br><span class="line">alert(ints4.buffer.byteLength); <span class="comment">// 8</span></span><br><span class="line">alert(ints4[<span class="number">2</span>]); <span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 从一个普通数组创建Int16Array类型化数组</span></span><br><span class="line"><span class="keyword">const</span> ints5 = <span class="built_in">Int16Array</span>.from([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]);</span><br><span class="line">alert(ints5.length); <span class="comment">// 4</span></span><br><span class="line">alert(ints5.buffer.byteLength); <span class="comment">// 8</span></span><br><span class="line">alert(ints5[<span class="number">2</span>]); <span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 用参数创建Float32Array类型化数组</span></span><br><span class="line"><span class="keyword">const</span> floats = <span class="built_in">Float32Array</span>.of(<span class="number">3.14</span>, <span class="number">2.718</span>, <span class="number">1.618</span>);</span><br><span class="line">alert(floats.length); <span class="comment">// 3</span></span><br><span class="line">alert(floats.buffer.byteLength); <span class="comment">// 12</span></span><br><span class="line">alert(floats[<span class="number">2</span>]); <span class="comment">// 1.6180000305175781</span></span><br></pre></td></tr></table></figure>

<p>构造函数和实例都有一个 BYTES_PER_ELEMENT 属性，该属性返回该类型数组中每个元素的字节数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Int16Array</span>.BYTES_PER_ELEMENT); <span class="comment">// 2</span></span><br><span class="line">alert(<span class="built_in">Int32Array</span>.BYTES_PER_ELEMENT); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">1</span>),</span><br><span class="line">  floats = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="number">1</span>);</span><br><span class="line">alert(ints.BYTES_PER_ELEMENT); <span class="comment">// 4</span></span><br><span class="line">alert(floats.BYTES_PER_ELEMENT); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>除非使用具体值来初始化类型化数组，否则其关联的 buffer 由 0 填充:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">4</span>);</span><br><span class="line">alert(ints[<span class="number">0</span>]); <span class="comment">// 0</span></span><br><span class="line">alert(ints[<span class="number">1</span>]); <span class="comment">// 0</span></span><br><span class="line">alert(ints[<span class="number">2</span>]); <span class="comment">// 0</span></span><br><span class="line">alert(ints[<span class="number">3</span>]); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h5 id="类型化数组行为"><a href="#类型化数组行为" class="headerlink" title="类型化数组行为"></a>类型化数组行为</h5><p>在大多数情况下，类型化数组的行为与常规数组的行为类似。类型化数组支持以下操作符、方法和属性:</p>
<ul>
<li>[]</li>
<li>copyWithin()</li>
<li>entries()</li>
<li>every()</li>
<li>fill()</li>
<li>filter()</li>
<li>find()</li>
<li>findIndex()</li>
<li>forEach()</li>
<li>indexOf()</li>
<li>join()</li>
<li>keys()</li>
<li>lastIndexOf()</li>
<li>length</li>
<li>map()</li>
<li>reduce()</li>
<li>reduceRight()</li>
<li>reverse()</li>
<li>copyWithin()</li>
<li>entries()</li>
<li>every()</li>
<li>fill()</li>
<li>filter()</li>
<li>find()</li>
<li>findIndex()</li>
<li>forEach()</li>
<li>indexOf()</li>
<li>join()</li>
<li>keys()</li>
<li>lastIndexOf()</li>
<li>length</li>
<li>map()</li>
<li>reduce()</li>
<li>reduceRight()</li>
<li>reverse(）</li>
</ul>
<p>返回新数组的方法使用时将返回具有相同元素类型的类型化数组:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> doubleints = ints.map(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="number">2</span> * x);</span><br><span class="line">alert(doubleints <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>类型化数组定义了一个 Symbol.iterator，意味着也可以使用..of 循环和扩展操作符:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> int <span class="keyword">of</span> ints) &#123;</span><br><span class="line">  alert(int);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">alert(<span class="built_in">Math</span>.max(...ints)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h5 id="合并、复制和更改类型化数组"><a href="#合并、复制和更改类型化数组" class="headerlink" title="合并、复制和更改类型化数组"></a>合并、复制和更改类型化数组</h5><p>类型化的数组仍然使用 array buffer 作为存储空间，而且 buffer 不能调整大小。因此，类型化数组不支持以下方法:</p>
<ul>
<li>concat()</li>
<li>pop()</li>
<li>push()</li>
<li>shift()</li>
<li>splice()</li>
<li>unshift()</li>
</ul>
<p>但是，类型化数组确实提供了两种新的方法：set()和 subarray()，可以快速地从数组中复制值。</p>
<p>Set()将提供的数组或类型化数组中的值复制到当前类型化数组中的指定索引处:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度为8的Int16Array类型化数组</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 复制一个类型化数组到前四个值</span></span><br><span class="line"><span class="comment">// Offset偏移默认是0</span></span><br><span class="line">container.set(<span class="built_in">Int8Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">alert(container); <span class="comment">// [1,2,3,4,0,0,0,0]</span></span><br><span class="line"><span class="comment">// 复制一个普通数组到后四个值</span></span><br><span class="line"><span class="comment">// Offset为4代表着从第四个索引处插入</span></span><br><span class="line">container.set([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">4</span>);</span><br><span class="line">alert(container); <span class="comment">// [1,2,3,4,5,6,7,8]</span></span><br><span class="line"><span class="comment">// 溢出后抛出一个error</span></span><br><span class="line">container.set([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">7</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure>

<p>subarray()执行与 set()相反的操作，返回一个值从源数组复制出来的新的类型化数组。可提供开始和结束位置两个可选参数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="built_in">Int16Array</span>.of(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 复制完整的数组到一个相同类型的新数组中</span></span><br><span class="line"><span class="keyword">const</span> fullCopy = source.subarray();</span><br><span class="line">alert(fullCopy); <span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 从第二个索引处开始复制数组</span></span><br><span class="line"><span class="keyword">const</span> halfCopy = source.subarray(<span class="number">2</span>);</span><br><span class="line">alert(halfCopy); <span class="comment">// [6, 8]</span></span><br><span class="line"><span class="comment">// 复制1到3索引位置处的数组</span></span><br><span class="line"><span class="keyword">const</span> partialCopy = source.subarray(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">alert(partialCopy); <span class="comment">// [4, 6]</span></span><br></pre></td></tr></table></figure>

<p>类型化数组不具备原生的连接数组的方法，但是可以利用类型化数组的 API 手动构建该方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是应当返回的数组类型，剩余参数是需要连接的类型化数组</span></span><br><span class="line"><span class="comment">// Remaining arguments are all the typed arrays that should be concatenated</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typedArrayConcat</span>(<span class="params">typedArrayConstructor, ...typedArrays</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 计算出整个数组中的元素数目</span></span><br><span class="line">  <span class="keyword">const</span> numElements = typedArrays.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> (x.length || x) + y.length);</span><br><span class="line">  <span class="comment">// 为所有的元素提供一个空的指定类型的数组</span></span><br><span class="line">  <span class="keyword">const</span> resultArray = <span class="keyword">new</span> typedArrayConstructor(numElements);</span><br><span class="line">  <span class="comment">// 执行数组转换</span></span><br><span class="line">  <span class="keyword">let</span> currentOffset = <span class="number">0</span>;</span><br><span class="line">  typedArrays.map(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    resultArray.set(x, currentOffset);</span><br><span class="line">    currentOffset += x.length;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> resultArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> concatArray = typedArrayConcat(</span><br><span class="line">  <span class="built_in">Int32Array</span>,</span><br><span class="line">  <span class="built_in">Int8Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">  <span class="built_in">Int16Array</span>.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">  <span class="built_in">Float32Array</span>.of(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">);</span><br><span class="line">alert(concatArray); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">alert(concatArray <span class="keyword">instanceof</span> <span class="built_in">Int32Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="向上和向下溢出"><a href="#向上和向下溢出" class="headerlink" title="向上和向下溢出"></a>向上和向下溢出</h5><p>类型化数组中值不会向上或向下溢出到其他索引中，但是仍然必须考虑数组相关的元素类型。类型化数组只接受数组中每个索引可以容纳的相关位，而不考虑它对实际数值的影响。下面演示如何处理向上和向下溢出:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ints是一个长度为2的数组</span></span><br><span class="line"><span class="comment">// 每一个索引都可以容纳2进制带符号整数补码，范围从-128 (-1 * 2^7) 到 127 (2^7 – 1)。</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// unsignedInts是一个长度为2的数组</span></span><br><span class="line"><span class="comment">// 每一个索引都可以容纳无符号整数，范围从0 到 255 (2^7 – 1)。</span></span><br><span class="line"><span class="keyword">const</span> unsignedInts = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 向上溢出位不会影响到相邻的索引</span></span><br><span class="line"><span class="comment">// 每个索引只采用最低的8个有效位</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">256</span>; <span class="comment">// 0x100 100000000</span></span><br><span class="line">alert(unsignedInts); <span class="comment">// [0, 0]</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">511</span>; <span class="comment">// 0x1FF 111111111</span></span><br><span class="line">alert(unsignedInts); <span class="comment">// [0, 255]</span></span><br><span class="line"><span class="comment">// 向下溢出位将会转化为无符号的等效位</span></span><br><span class="line"><span class="comment">// 0xFF是-1，作为2进制整数补码(8位截断)。</span></span><br><span class="line"><span class="comment">// 但是255是无符号整型</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">-1</span>; <span class="comment">// 0xFF (8位截断) 11111111</span></span><br><span class="line">alert(unsignedInts); <span class="comment">// [0, 255]</span></span><br><span class="line"><span class="comment">// 2的补码上溢。</span></span><br><span class="line"><span class="comment">// 0x80表示无符号整型数128，而-128表示2进制整型数补码</span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">128</span>; <span class="comment">// 0x80 10000000</span></span><br><span class="line">alert(ints); <span class="comment">// [0, -128]</span></span><br><span class="line"><span class="comment">// 2的补码下溢。</span></span><br><span class="line"><span class="comment">// 0xFF表示无符号整型数255，而-1表示2进制整型数补码</span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">255</span>; <span class="comment">// 0xFF 11111111</span></span><br><span class="line">alert(ints); <span class="comment">// [0, -1]</span></span><br></pre></td></tr></table></figure>

<p>除了八个元素类型之外，还有一个额外的“夹紧”数组类型 Uint8ClampedArray，它可以防止向任何一个方向溢出。高于其最大值 255 的数值将四舍五入到 255，低于 0 的数值将四舍五入到 0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clampedInts = <span class="keyword">new</span> <span class="built_in">Uint8ClampedArray</span>([<span class="number">-1</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">256</span>]);</span><br><span class="line">alert(clampedInts); <span class="comment">// [0, 0, 255, 255]</span></span><br></pre></td></tr></table></figure>

<p>根据 Brendan Eich 的说法，“Uint8ClampedArray 完全是 HTML5 canvas 元素的历史产物。除非你真的在做类似 canvas-y 的东西，否则要避免使用 Uint8ClampedArray 。”</p>
<h3 id="Map-类型"><a href="#Map-类型" class="headerlink" title="Map 类型"></a>Map 类型</h3><p>在 ECMAScript6 规范之前，通过使用 Object，对象属性作为键，属性引用作为值，可以有效且容易地在 JavaScript 中实现键/值存储。然而这种实现方式有一定缺陷，因此 TC39 委员会认为应该为实现真正的键/值存储定义一个规范。</p>
<p>Map 是 ECMAScript6 中新添加的一种集合类型，向语言中引入了真正的键/值行为。Map 的大部分内容与 Object 类型的内容重叠，但是在选择要使用 Object 和 Map 类型时应该考虑到它们之间的细微差别。</p>
<h4 id="基础-API"><a href="#基础-API" class="headerlink" title="基础 API"></a>基础 API</h4><p>使用 new 关键字实例化一个空的 Map 实例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure>

<p>如果希望在 Map 初始化就填充键值对，那么构造函数可接受一个包含键/值对数组的可迭代对象。迭代参数中的每一对键值都将按顺序插入到新创建的 Map 实例中:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用嵌套数组来初始化一个Map实例</span></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'key1'</span>, <span class="string">'val1'</span>],</span><br><span class="line">  [<span class="string">'key2'</span>, <span class="string">'val2'</span>],</span><br><span class="line">  [<span class="string">'key3'</span>, <span class="string">'val3'</span>],</span><br><span class="line">]);</span><br><span class="line">alert(m1.size); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化一个Map实例</span></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">'key1'</span>, <span class="string">'val1'</span>];</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">'key2'</span>, <span class="string">'val2'</span>];</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">'key3'</span>, <span class="string">'val3'</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">alert(m2.size); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 无论是否提供了键值对，Map期望值都是键值对</span></span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="built_in">Map</span>([[]]);</span><br><span class="line">alert(m3.has(<span class="literal">undefined</span>)); <span class="comment">// true</span></span><br><span class="line">alert(m3.get(<span class="literal">undefined</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>初始化后可以使用 set()方法添加键/值对，使用 get()和 has()方法查询，使用 size 属性计数，使用 delete()和 clear()方法删除键/值对:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">alert(m.has(<span class="string">'firstName'</span>)); <span class="comment">// false</span></span><br><span class="line">alert(m.get(<span class="string">'firstName '</span>)); <span class="comment">// undefined</span></span><br><span class="line">alert(m.size); <span class="comment">// 0</span></span><br><span class="line">m.set(<span class="string">'firstName'</span>, <span class="string">'Matt'</span>).set(<span class="string">'lastName'</span>, <span class="string">'Frisbie'</span>);</span><br><span class="line">alert(m.has(<span class="string">'firstName'</span>)); <span class="comment">// true</span></span><br><span class="line">alert(m.get(<span class="string">'firstName'</span>)); <span class="comment">// Matt</span></span><br><span class="line">alert(m.size); <span class="comment">// 2</span></span><br><span class="line">m.delete(<span class="string">'firstName'</span>); <span class="comment">// 只删除这一个键值对</span></span><br><span class="line">alert(m.has(<span class="string">'firstName'</span>)); <span class="comment">// false</span></span><br><span class="line">alert(m.has(<span class="string">'lastName'</span>)); <span class="comment">// true</span></span><br><span class="line">alert(m.size); <span class="comment">// 1</span></span><br><span class="line">m.clear(); <span class="comment">// 删除所有的键值对</span></span><br><span class="line">alert(m.has(<span class="string">'firstName'</span>)); <span class="comment">// false</span></span><br><span class="line">alert(m.has(<span class="string">'lastName'</span>)); <span class="comment">// false</span></span><br><span class="line">alert(m.size); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>set() 方法返回 Map 实例，因此可以将多个 set 操作链接在一起，包括初始声明:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'key1'</span>, <span class="string">'val1'</span>);</span><br><span class="line">m.set(<span class="string">'key2'</span>, <span class="string">'val2'</span>).set(<span class="string">'key3'</span>, <span class="string">'val3'</span>);</span><br><span class="line">alert(m.size); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>Object 只能使用数字或字符串作为键，但是 Map 可以使用任何 JavaScript 数据类型作为键。它使用“SameValueZero”比较操作(在 ECMAScript 规范中定义，在实际语言中不可用)，与使用严格对象等价检查的键名匹配基本相似。与 Object 一样，对于值中包含的内容没有限制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> functionKey = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> objectKey = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">m.set(functionKey, <span class="string">'functionValue'</span>);</span><br><span class="line">m.set(symbolKey, <span class="string">'symbolValue'</span>);</span><br><span class="line">m.set(objectKey, <span class="string">'objectValue'</span>);</span><br><span class="line">alert(m.get(functionKey)); <span class="comment">// functionValue</span></span><br><span class="line">alert(m.get(symbolKey)); <span class="comment">// symbolValue</span></span><br><span class="line">alert(m.get(objectKey)); <span class="comment">// objectValue</span></span><br><span class="line"><span class="comment">// SameValueZero检查意味着不同实例不会造成冲突</span></span><br><span class="line">alert(m.get(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>与严格等价一样，当内容或属性改变时，Map 中用于键和值的对象和其他“集合”类型保持不变:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> objKey = &#123;&#125;,</span><br><span class="line">  objVal = &#123;&#125;,</span><br><span class="line">  arrKey = [],</span><br><span class="line">  arrVal = [];</span><br><span class="line">m.set(objKey, objVal);</span><br><span class="line">m.set(arrKey, arrVal);</span><br><span class="line">objKey.foo = <span class="string">'foo'</span>;</span><br><span class="line">objVal.bar = <span class="string">'bar'</span>;</span><br><span class="line">arrKey.push(<span class="string">'foo'</span>);</span><br><span class="line">arrVal.push(<span class="string">'bar'</span>);</span><br><span class="line">alert(m.get(objKey)); <span class="comment">// &#123;bar: "bar"&#125;</span></span><br><span class="line">alert(m.get(arrKey)); <span class="comment">// ["bar"]</span></span><br></pre></td></tr></table></figure>

<p>使用 SameValueZero 操作可能会引发意外的冲突:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">0</span> / <span class="string">''</span>, <span class="comment">// NaN</span></span><br><span class="line">  b = <span class="number">0</span> / <span class="string">''</span>, <span class="comment">// NaN</span></span><br><span class="line">  pz = +<span class="number">0</span>,</span><br><span class="line">  nz = <span class="number">-0</span>;</span><br><span class="line">alert(a === b); <span class="comment">// false</span></span><br><span class="line">alert(pz === nz); <span class="comment">// true</span></span><br><span class="line">m.set(a, <span class="string">'foo'</span>);</span><br><span class="line">m.set(pz, <span class="string">'bar'</span>);</span><br><span class="line">alert(m.get(b)); <span class="comment">// foo</span></span><br><span class="line">alert(m.get(nz)); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：SameValueZero 操作对于 ECMAScript 规范来说是新的内容。在 Mozilla 的文档网站上有一篇关于 SameValueZero 和其他 ECMAScript 等价约定的优秀文章<code>https://developer.mozilla.org/en-US/docs/ Web/JavaScript/Equality_comparisons_and_sameness</code>。</p>
</blockquote>
<h4 id="顺序和迭代"><a href="#顺序和迭代" class="headerlink" title="顺序和迭代"></a>顺序和迭代</h4><p>与 Object 类型的一个主要区别是，Map 实例维护键值对插入的顺序，并允许按照插入顺序执行迭代操作。</p>
<p>Map 实例可以提供一个迭代器，该迭代器内按插入顺序排列形式为[key，value]的数组对。可以使用 entries()或 symboli.iterator 属性检索该迭代器（实际是引用了 entries()），如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'key1'</span>, <span class="string">'val1'</span>],</span><br><span class="line">  [<span class="string">'key2'</span>, <span class="string">'val2'</span>],</span><br><span class="line">  [<span class="string">'key3'</span>, <span class="string">'val3'</span>],</span><br><span class="line">]);</span><br><span class="line">alert(m.entries === m[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m.entries()) &#123;</span><br><span class="line">  alert(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [key1,val1]</span></span><br><span class="line"><span class="comment">// [key2,val2]</span></span><br><span class="line"><span class="comment">// [key3,val3]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m[<span class="built_in">Symbol</span>.iterator]()) &#123;</span><br><span class="line">  alert(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [key1,val1]</span></span><br><span class="line"><span class="comment">// [key2,val2]</span></span><br><span class="line"><span class="comment">// [key3,val3]</span></span><br></pre></td></tr></table></figure>

<p>因为 entries()是默认的迭代器，所以可以使用扩展操作符方便地将 Map 转换为数组:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'key1'</span>, <span class="string">'val1'</span>],</span><br><span class="line">  [<span class="string">'key2'</span>, <span class="string">'val2'</span>],</span><br><span class="line">  [<span class="string">'key3'</span>, <span class="string">'val3'</span>],</span><br><span class="line">]);</span><br><span class="line">alert([...m]); <span class="comment">// [[key1,val1],[key2,val2],[key3,val3]]</span></span><br></pre></td></tr></table></figure>

<p>forEach(callback，optthisarg)为每个键值对调用回调函数而不是迭代器。有第二个可选参数，该参数将覆盖每个回调函数内部的 this 参数的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'key1'</span>, <span class="string">'val1'</span>],</span><br><span class="line">  [<span class="string">'key2'</span>, <span class="string">'val2'</span>],</span><br><span class="line">  [<span class="string">'key3'</span>, <span class="string">'val3'</span>],</span><br><span class="line">]);</span><br><span class="line">m.forEach(<span class="function">(<span class="params">val, key</span>) =&gt;</span> alert(<span class="string">`<span class="subst">$&#123;key&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// key1 -&gt; val1</span></span><br><span class="line"><span class="comment">// key2 -&gt; val2</span></span><br><span class="line"><span class="comment">// key3 -&gt; val3</span></span><br></pre></td></tr></table></figure>

<p>Keys()和 values()返回一个迭代器，该迭代器按照排序顺序迭代 Map 中的所有键或所有值:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'key1'</span>, <span class="string">'val1'</span>],</span><br><span class="line">  [<span class="string">'key2'</span>, <span class="string">'val2'</span>],</span><br><span class="line">  [<span class="string">'key3'</span>, <span class="string">'val3'</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123;</span><br><span class="line">  alert(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key1</span></span><br><span class="line"><span class="comment">// key2</span></span><br><span class="line"><span class="comment">// key3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.values()) &#123;</span><br><span class="line">  alert(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value1</span></span><br><span class="line"><span class="comment">// value2</span></span><br><span class="line"><span class="comment">// value3</span></span><br></pre></td></tr></table></figure>

<p>迭代器中的键和值是可变的，但不能更改 Map 中的引用。但是，并不限制键或值对象内的属性更改。如下行为不会改变键和值对于 Map 实例的关系:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>, <span class="string">'val1'</span>]]);</span><br><span class="line"><span class="comment">// 原始字符串键名不可替换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123;</span><br><span class="line">  key = <span class="string">'newKey'</span>;</span><br><span class="line">  alert(key); <span class="comment">// newKey</span></span><br><span class="line">  alert(m.get(<span class="string">'key1'</span>)); <span class="comment">// val1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> keyObj = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[keyObj, <span class="string">'val1'</span>]]);</span><br><span class="line"><span class="comment">// 键名对象的属性更改，但是这个对象在Map实例内部仍然指向相同的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123;</span><br><span class="line">  key.id = <span class="string">'newKey'</span>;</span><br><span class="line">  alert(key); <span class="comment">// &#123;id: "newKey"&#125;</span></span><br><span class="line">  alert(m.get(keyObj)); <span class="comment">// val1</span></span><br><span class="line">&#125;</span><br><span class="line">alert(keyObj); <span class="comment">// &#123;id: "newKey"&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="在-Objects-和-Map-之间选择"><a href="#在-Objects-和-Map-之间选择" class="headerlink" title="在 Objects 和 Map 之间选择"></a>在 Objects 和 Map 之间选择</h4><p>对于大多数 web 开发来说，在 Map 或者普通 Object 之间进行选择只是一个个人喜好问题，在其他方面几乎没有什么影响。然而，对于关心内存和性能的开发者来说，Object 和 Map 之间存在着显著的差异。</p>
<h5 id="内存文件"><a href="#内存文件" class="headerlink" title="内存文件"></a>内存文件</h5><p>不同浏览器的 Object 和 Map 的在引擎级别实现时会有明显的差异，但是存储键值对所需的内存量与键的数量成线性关系。键值对的批量添加或删除还取决于引擎如何实现该类型的内存分配。虽然结果可能因浏览器而异，但是给定一个固定的内存量，Map 能够比 Object 多存储大约 50%的键值对。</p>
<h5 id="插入性能"><a href="#插入性能" class="headerlink" title="插入性能"></a>插入性能</h5><p>在 Object 和 Map 中插入一个新的键值对是大致相同的操作，但是在所有的浏览器引擎中插入 Map 通常会稍微快一些。对于这两种类型来说，插入的速度不都会随 Object 或 Map 中键值对的数量线性降低。如果代码大量使用插入操作，则 Map 实例提供更好一点的性能。</p>
<h5 id="查找性能"><a href="#查找性能" class="headerlink" title="查找性能"></a>查找性能</h5><p>与插入操作不同，在 Object 和 Map 中查找键值对的速度上大致相当，但在某些情况下，较少数量的键值对时，Object 实例会更快。在将 Object 实例用作数组的情况下(例如，连续的整数属性)，浏览器引擎可以执行优化（例如在内存中提高布局效率）ーー这在 Map 中是不可能的。对于这两种类型，查找速度不会随 Object 或 Map 中键值对的数量线性变慢。如果您的代码大量使用查找操作，在某些情况下使用 Object 可能更为有利。</p>
<h5 id="删除性能"><a href="#删除性能" class="headerlink" title="删除性能"></a>删除性能</h5><p>对 Object 属性执行的删除操作的性能是臭名昭著的，这在许多浏览器引擎中仍然很常见。删除对象属性的伪解决方案包括将属性值设为 undefined 的或 null，但在许多情况下，这是不合适的折衷方案。在大多数浏览器引擎中，Map 的 delete()操作比插入和查找更快。如果代码大量使用删除操作，则 Map 类型是最合适的类型。</p>
<h3 id="WeakMap-类型"><a href="#WeakMap-类型" class="headerlink" title="WeakMap 类型"></a>WeakMap 类型</h3><p>在 ECMAScript6 中新添加的 WeakMap 类型是一种新的集合类型，它在语言中引入了增强的键值行为。Weakmap 类型是 Map 类型的近亲，它的 API 是 Map 类型 API 的严格子集。“弱（weak）”这个名称描述了 JavaScript 的垃圾回收器如何处理 Weakmap。</p>
<h4 id="基础-API-1"><a href="#基础-API-1" class="headerlink" title="基础 API"></a>基础 API</h4><p>使用 new 关键字实例化一个空的 WeakMap:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  key2 = &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  key3 = &#123; <span class="attr">id</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="comment">// 使用潜逃数组实例化一个WeakMap</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([</span><br><span class="line">  [key1, <span class="string">'val1'</span>],</span><br><span class="line">  [key2, <span class="string">'val2'</span>],</span><br><span class="line">  [key3, <span class="string">'val3'</span>],</span><br><span class="line">]);</span><br><span class="line">alert(wm.get(key1)); <span class="comment">// val2</span></span><br><span class="line">alert(wm.get(key2)); <span class="comment">// val2</span></span><br><span class="line">alert(wm.get(key3)); <span class="comment">// val3</span></span><br><span class="line"><span class="comment">// 实例化过程是一个要么全有要么全无的过程，一个错误的键名会抛出一个error并中止实例化过程</span></span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([</span><br><span class="line">  [key1, <span class="string">'val1'</span>],</span><br><span class="line">  [<span class="string">'BADKEY'</span>, <span class="string">'val2'</span>],</span><br><span class="line">  [key3, <span class="string">'val3'</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as WeakMap key</span></span><br><span class="line"><span class="keyword">typeof</span> wm2;</span><br><span class="line"><span class="comment">// ReferenceError: wm2 is not defined</span></span><br><span class="line"><span class="comment">// 使用对象封装的原始类型仍然可以使用</span></span><br><span class="line"><span class="keyword">const</span> stringKey = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'key1'</span>);</span><br><span class="line"><span class="keyword">const</span> wm3 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([stringKey, <span class="string">'val1'</span>]);</span><br><span class="line">alert(wm3.get(stringKey)); <span class="comment">// "val1"</span></span><br></pre></td></tr></table></figure>

<p>键值对可以在初始化后使用 set()方法添加，用 get()方法和 has()方法查询，用 delete()方法删除:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key1 = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  key2 = &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;;</span><br><span class="line">alert(wm.has(key1)); <span class="comment">// false</span></span><br><span class="line">alert(wm.get(key1)); <span class="comment">// undefined</span></span><br><span class="line">wm.set(key1, <span class="string">'Matt'</span>).set(key2, <span class="string">'Frisbie'</span>);</span><br><span class="line">alert(wm.has(key1)); <span class="comment">// true</span></span><br><span class="line">alert(wm.get(key1)); <span class="comment">// Matt</span></span><br><span class="line">wm.delete(key1); <span class="comment">// 只删除这一个键值对</span></span><br><span class="line">alert(wm.has(key1)); <span class="comment">// false</span></span><br><span class="line">alert(wm.has(key2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>set()方法返回 WeakMap 实例，因此可以将多个 set 操作包括初始声明链接在一起:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  key2 = &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  key3 = &#123; <span class="attr">id</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>().set(key1, <span class="string">'val1'</span>);</span><br><span class="line">wm.set(key2, <span class="string">'val2'</span>).set(key3, <span class="string">'val3'</span>);</span><br><span class="line">alert(wm.get(key1)); <span class="comment">// val1</span></span><br><span class="line">alert(wm.get(key2)); <span class="comment">// val2</span></span><br><span class="line">alert(wm.get(key3)); <span class="comment">// val3</span></span><br></pre></td></tr></table></figure>

<h4 id="弱键"><a href="#弱键" class="headerlink" title="弱键"></a>弱键</h4><p>“弱（weak）”源于 WeakMap 中的键名是“弱持有（weakly held）”的，这意味着它们不被计算为正式的引用，也就不会阻止垃圾收集。Weakmap 的一个重要区别是值引用不被弱持有。只要键名存在，键值对就会保留在映射中，并作为对该值的引用计数，从而防止对该值进行垃圾收集。</p>
<p>比如下面的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">wm.set(&#123;&#125;, <span class="string">'val'</span>);</span><br></pre></td></tr></table></figure>

<p>在 set()中，将初始化一个新对象，并将其用作虚拟字符串的键。因为没有对这个对象的其他引用，所以只要执行完这一行，对象键名就可以用于垃圾收集。发生这种情况时，键值对将从 WeakMap 中消失且为空。在这个示例中，由于没有对该键值的其他引用，这个键值对删除还意味着该键值可以进行垃圾收集。</p>
<p>参考一个稍微不同的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> container = &#123;</span><br><span class="line">  key: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">wm.set(container.key, <span class="string">'val'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeReference</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  container.key = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，container 对象维护对 WeakMap 中键的引用，因此该对象不适用于垃圾收集。但是，一旦调用 removeReference()，对键对象的最后一个强引用将被销毁，垃圾收集机制最终将清除键值对。</p>
<h4 id="不可迭代的键"><a href="#不可迭代的键" class="headerlink" title="不可迭代的键"></a>不可迭代的键</h4><p>由于 WeakMap 中的键值对可以随时销毁，因此提供遍历键值对的能力是无意义的。这也排除了使用 clear()一次销毁所有键值对的需求，clear()不是 WeakMap API 的一部分。因为不允许迭代，所以也不可能从 WeakMap 实例检索值（除非您有对键对象的引用）。即使代码可以访问 WeakMap 实例，也无法检查其内容。</p>
<p>Weakmap 实例将键名限制只为对象的原因是为了遵守这样一个约定：即从 WeakMap 中只能通过引用键对象检索值。如果允许原始类型，WeakMap 实例将无法区分最初用于设置键值对的字符串原始类型和后来初始化的相同字符串原始类型ーー这是一种不希望出现的行为。</p>
<h4 id="实用性"><a href="#实用性" class="headerlink" title="实用性"></a>实用性</h4><p>Weakmap 实例与现有的 JavaScript 工具有着显著的不同，并且没有很明显地指示出应该如何使用。这个问题没有一个简单的答案，但已经出现了一些策略。</p>
<h5 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h5><p>Weakmap 实例为在 JavaScript 实现真正的私有变量提供了一种全新的方式。前提比较直接：私有变量将存储在 WeakMap 中，对象实例作为键名，私有成员字典作为值。</p>
<p>实现方式如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.idProperty = <span class="built_in">Symbol</span>(<span class="string">'id'</span>);</span><br><span class="line">    <span class="keyword">this</span>.setId(id);</span><br><span class="line">  &#125;</span><br><span class="line">  setPrivate(property, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> privateMembers = wm.get(<span class="keyword">this</span>) || &#123;&#125;;</span><br><span class="line">    privateMembers[property] = value;</span><br><span class="line">    wm.set(<span class="keyword">this</span>, privateMembers);</span><br><span class="line">  &#125;</span><br><span class="line">  getPrivate(property) &#123;</span><br><span class="line">    <span class="keyword">return</span> wm.get(<span class="keyword">this</span>)[property];</span><br><span class="line">  &#125;</span><br><span class="line">  setId(id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setPrivate(<span class="keyword">this</span>.idProperty, id);</span><br><span class="line">  &#125;</span><br><span class="line">  getId() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getPrivate(<span class="keyword">this</span>.idProperty);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>);</span><br><span class="line">alert(user.getId()); <span class="comment">// 123</span></span><br><span class="line">user.setId(<span class="number">456</span>);</span><br><span class="line">alert(user.getId()); <span class="comment">// 456</span></span><br><span class="line"><span class="comment">// 证明这不是一个真正私有变量</span></span><br><span class="line">alert(wm.get(user)[user.idProperty]); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<p>仔细观察可以发现，在这种实现中，外部代码只需要对对象实例和 WeakMap 的引用，就可以检索私有变量。为了防止这种情况，可以将 WeakMap 包装在一个闭包中以便完全隐藏 WeakMap 实例，不让外部代码看到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line">      <span class="keyword">this</span>.idProperty = <span class="built_in">Symbol</span>(<span class="string">'id'</span>);</span><br><span class="line">      <span class="keyword">this</span>.setId(id);</span><br><span class="line">    &#125;</span><br><span class="line">    setPrivate(property, value) &#123;</span><br><span class="line">      <span class="keyword">const</span> privateMembers = wm.get(<span class="keyword">this</span>) || &#123;&#125;;</span><br><span class="line">      privateMembers[property] = value;</span><br><span class="line">      wm.set(<span class="keyword">this</span>, privateMembers);</span><br><span class="line">    &#125;</span><br><span class="line">    getPrivate(property) &#123;</span><br><span class="line">      <span class="keyword">return</span> wm.get(<span class="keyword">this</span>)[property];</span><br><span class="line">    &#125;</span><br><span class="line">    setId(id) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setPrivate(<span class="keyword">this</span>.idProperty, id);</span><br><span class="line">    &#125;</span><br><span class="line">    getId(id) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.getPrivate(<span class="keyword">this</span>.idProperty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> User;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>);</span><br><span class="line">alert(user.getId()); <span class="comment">// 123</span></span><br><span class="line">user.setId(<span class="number">456</span>);</span><br><span class="line">alert(user.getId()); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<p>因此，如果没有用于插入的键，就不能检索 WeakMap 中的值。尽管这会阻止前面提到的私有变量的访问模式，但在某些方面，它将代码推向了 ES6 之前的闭包私有变量模式。</p>
<h5 id="DOM-节点元数据"><a href="#DOM-节点元数据" class="headerlink" title="DOM 节点元数据"></a>DOM 节点元数据</h5><p>因为 WeakMap 实例不会干扰垃圾收集，所以它可用于清除无需清除的元数据关联。比如下面的例子，使用了一个普通的 Map:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="built_in">document</span>.querySelector(<span class="string">'#login'</span>);</span><br><span class="line"><span class="comment">// 关联一些节点的元数据</span></span><br><span class="line">m.set(loginButton, &#123; <span class="attr">disabled</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>假设这段代码执行后，页面被 JavaScript 更改，登录按钮从 DOM 树中删除。由于在 Map 中存在一个引用，所以 DOM 节点将永久地停留在内存中，直到显式地从 Map 中删除或者 Map 被销毁。</p>
<p>如果使用 WeakMap，如下面的代码所示，从 DOM 中删除节点将允许垃圾收集器立即释放分配的内存(假设没有其他对象的延迟引用)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="built_in">document</span>.querySelector(<span class="string">'#login'</span>);</span><br><span class="line"><span class="comment">// 关联一些节点的元数据</span></span><br><span class="line">wm.set(loginButton, &#123; <span class="attr">disabled</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Set-类型"><a href="#Set-类型" class="headerlink" title="Set 类型"></a>Set 类型</h3><p>在 ECMAScript6 中新添加的 Set 是一种新的集合类型，引入了 set 行为。因为许多 API 和行为都是共享的，Set 在很多方面更像是一个扩展的 Map。</p>
<h4 id="基础-API-2"><a href="#基础-API-2" class="headerlink" title="基础 API"></a>基础 API</h4><p>使用 new 关键字实例化一个空的 Set 类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure>

<p>如果希望在初始化时就填充，构造函数可以选择接受一个要添加到新创建的 Set 实例中的元素组成的的可迭代对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数组实例化一个Set</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"val1"</span>, <span class="string">"val2"</span>, <span class="string">"val3]);</span></span><br><span class="line"><span class="string">alert(s1.size); // 3</span></span><br><span class="line"><span class="string">// 使用自定义迭代器实例化一个Set</span></span><br><span class="line"><span class="string">const s2 = new Set(&#123;</span></span><br><span class="line"><span class="string">  [Symbol.iterator]: function*() &#123;</span></span><br><span class="line"><span class="string">    yield "</span>val1<span class="string">";</span></span><br><span class="line"><span class="string">    yield "</span>val2<span class="string">";</span></span><br><span class="line"><span class="string">    yield "</span>val3<span class="string">";</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">alert(s2.size); // 3</span></span><br></pre></td></tr></table></figure>

<p>初始化后使用 add()方法可以添加值，使用 has()方法查询值，使用 size 属性计数，使用 delete()和 clear()方法删除值:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">alert(s.has(<span class="string">'Matt'</span>)); <span class="comment">// false</span></span><br><span class="line">alert(s.size); <span class="comment">// 0</span></span><br><span class="line">s.add(<span class="string">'Matt'</span>).add(<span class="string">'Frisbie'</span>);</span><br><span class="line">alert(s.has(<span class="string">'Matt'</span>)); <span class="comment">// true</span></span><br><span class="line">alert(s.size); <span class="comment">// 2</span></span><br><span class="line">s.delete(<span class="string">'Matt'</span>);</span><br><span class="line">alert(s.has(<span class="string">'Matt'</span>)); <span class="comment">// false</span></span><br><span class="line">alert(s.has(<span class="string">'Frisbie'</span>)); <span class="comment">// true</span></span><br><span class="line">alert(s.size); <span class="comment">// 1</span></span><br><span class="line">s.clear(); <span class="comment">// 销毁Set实例中所有的值</span></span><br><span class="line">alert(s.has(<span class="string">'Matt'</span>)); <span class="comment">// false</span></span><br><span class="line">alert(s.has(<span class="string">'Frisbie'</span>)); <span class="comment">// false</span></span><br><span class="line">alert(s.size); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>add()方法返回 Set 实例，因此可以将多个 add()操作（包括初始声明）连接在一起，:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">'val1'</span>);</span><br><span class="line">s.set(<span class="string">'val2'</span>).set(<span class="string">'val3'</span>);</span><br><span class="line">alert(s.size); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>像 Map 一样，Set 可以包含任何 JavaScript 数据类型作为值。它使用“SameValueZero”进行比较操作(在 ECMAScript 规范中定义，在实际语言中不可用)，与使用严格的对象等价来检查匹配大致相同。对于值中包含的内容没有限制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> functionVal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> symbolVal = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> objectVal = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">s.add(functionVal);</span><br><span class="line">s.add(symbolVal);</span><br><span class="line">s.add(objectVal);</span><br><span class="line">alert(s.has(functionVal)); <span class="comment">// true</span></span><br><span class="line">alert(s.has(symbolVal)); <span class="comment">// true</span></span><br><span class="line">alert(s.has(objectVal)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// SameValueZero 检查意味着相同内容的不同实例不会发生冲突</span></span><br><span class="line">alert(s.has(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>与严格等价一样，当用于值的对象和其他“集合（collection）”类型的内容或属性被更改时保持不变:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> objVal = &#123;&#125;,</span><br><span class="line">  arrVal = [];</span><br><span class="line">s.add(objVal).add(arrVal);</span><br><span class="line">objVal.bar = <span class="string">'bar'</span>;</span><br><span class="line">arrVal.push(<span class="string">'bar'</span>);</span><br><span class="line">alert(s.has(objVal)); <span class="comment">// true</span></span><br><span class="line">alert(s.has(arrVal)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Add()和 delete()操作是幂等的。delete()返回一个布尔值，指示该值是否存在于 set 中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(<span class="string">'foo'</span>);</span><br><span class="line">alert(s.size); <span class="comment">// 1</span></span><br><span class="line">s.add(<span class="string">'foo'</span>);</span><br><span class="line">alert(s.size); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 值在set种存在</span></span><br><span class="line">alert(s.delete(<span class="string">'foo'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 值在set种不存在</span></span><br><span class="line">alert(s.delete(<span class="string">'foo'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="顺序和迭代-1"><a href="#顺序和迭代-1" class="headerlink" title="顺序和迭代"></a>顺序和迭代</h4><p>Set 保持值插入的顺序，并允许按照插入顺序执行迭代操作。</p>
<p>Set 实例有将 Set 内容的按插入顺序排列的迭代器。可以使用 values()、别名 keys()或 symbolist.iterator 属性检索这个迭代器，这些都引用 values():</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'val1'</span>, <span class="string">'val2'</span>, <span class="string">'val3'</span>]);</span><br><span class="line">alert(s.values === s[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br><span class="line">alert(s.keys === s[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s.values()) &#123;</span><br><span class="line">  alert(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// val1</span></span><br><span class="line"><span class="comment">// val2</span></span><br><span class="line"><span class="comment">// val3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s[<span class="built_in">Symbol</span>.iterator]()) &#123;</span><br><span class="line">  alert(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// val1</span></span><br><span class="line"><span class="comment">// val2</span></span><br><span class="line"><span class="comment">// val3</span></span><br></pre></td></tr></table></figure>

<p>因为 value()是默认的迭代器，所以可以使用 spread 操作符简洁地将 set 转换为数组:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'val1'</span>, <span class="string">'val2'</span>, <span class="string">'val3'</span>]);</span><br><span class="line">alert([...s]); <span class="comment">// [val1,val2,val3]</span></span><br></pre></td></tr></table></figure>

<p>entries()返回一个迭代器，该迭代器包含一个二元素数组，该数组按插入顺序包含 Set 中所有值的副本:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'val1'</span>, <span class="string">'val2'</span>, <span class="string">'val3'</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> s.entries()) &#123;</span><br><span class="line">  alert(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [val1,val1]</span></span><br><span class="line"><span class="comment">// [val2,val2]</span></span><br><span class="line"><span class="comment">// [val3,val3]</span></span><br></pre></td></tr></table></figure>

<p>forEach(callback，optthisarg)调用每个值的回调时，使用回调函数而不是迭代器。接受第二个可选参数，该参数将覆盖每个回调函数内部的 this 指向。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'val1'</span>, <span class="string">'val2'</span>, <span class="string">'val3'</span>]);</span><br><span class="line">s.forEach(<span class="function">(<span class="params">val, dupVal</span>) =&gt;</span> alert(<span class="string">`<span class="subst">$&#123;val&#125;</span> -&gt; <span class="subst">$&#123;dupVal&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// val1 -&gt; val1</span></span><br><span class="line"><span class="comment">// val2 -&gt; val2</span></span><br><span class="line"><span class="comment">// val3 -&gt; val3</span></span><br></pre></td></tr></table></figure>

<p>更改 Set 中值的属性不会更改 Set 实例的值的 id：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'val1'</span>]);</span><br><span class="line"><span class="comment">// 原始字符串类型值不能更改</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> m.values()) &#123;</span><br><span class="line">  value = <span class="string">'newVal'</span>;</span><br><span class="line">  alert(value); <span class="comment">// newVal</span></span><br><span class="line">  alert(s.has(<span class="string">'val1'</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> valObj = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([valObj]);</span><br><span class="line"><span class="comment">// 值对象的属性改变了，但是这个对象依然存在在set中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s.values()) &#123;</span><br><span class="line">  value.id = <span class="string">'newVal'</span>;</span><br><span class="line">  alert(value); <span class="comment">// &#123;id: "newVal"&#125;</span></span><br><span class="line">  alert(s.has(valObj)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">alert(valObj); <span class="comment">// &#123;id: "newKey"&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="定义形式化的-Set-操作"><a href="#定义形式化的-Set-操作" class="headerlink" title="定义形式化的 Set 操作"></a>定义形式化的 Set 操作</h4><p>Set 在许多方面感觉像是 Map，只不过 API 稍微重新排列了一下。通过其 API 仅支持自引用操作来强调这一点。许多开发者对使用 Set 操作有兴趣，这需要采用继承 Set 的方式或定义实用程序库形式手工实现。为了同时提供这两种方式，可以在子类上实现静态方法，然后在实例方法中使用这些静态方法。在执行这些操作时，需要记住以下几点:</p>
<ul>
<li><p>有些 Set 操作是相互关联的，因此最好能够实现该方法以便它能够处理任意数量的 Set 实例是。</p>
</li>
<li><p>Set 保留插入顺序，从这些方法返回的 set 应该反映处这一事实。</p>
</li>
<li><p>尽可能高效地使用内存。扩展操作符提供了很好的语法，但尽可能避免在 set 和数组之间来回切换以节省对象初始化成本。</p>
</li>
<li><p>不要修改现有的 Set 实例。union(a, b) 或 a.union(b))应该返回一个新的 Set 类型的实例。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XSet</span> <span class="keyword">extends</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">  union(...sets) &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.union(<span class="keyword">this</span>, ...sets);</span><br><span class="line">  &#125;</span><br><span class="line">  intersection(...sets) &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.intersection(<span class="keyword">this</span>, ...sets);</span><br><span class="line">  &#125;</span><br><span class="line">  difference(<span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.difference(<span class="keyword">this</span>, <span class="keyword">set</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  symmetricDifference(<span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.symmetricDifference(<span class="keyword">this</span>, <span class="keyword">set</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cartesianProduct(<span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.cartesianProduct(<span class="keyword">this</span>, <span class="keyword">set</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  powerSet() &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.powerSet(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回多个set实例的并集</span></span><br><span class="line">  <span class="keyword">static</span> union(a, ...bSets) &#123;</span><br><span class="line">    <span class="keyword">const</span> unionSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        unionSet.add(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回多个set实例的交集</span></span><br><span class="line">  <span class="keyword">static</span> intersection(a, ...bSets) &#123;</span><br><span class="line">    <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> intersectionSet) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!b.has(aValue)) &#123;</span><br><span class="line">          intersectionSet.delete(aValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回多个set实例的补集</span></span><br><span class="line">  <span class="keyword">static</span> difference(a, b) &#123;</span><br><span class="line">    <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a.has(bValue)) &#123;</span><br><span class="line">        differenceSet.delete(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回多个set实例的对称差</span></span><br><span class="line">  <span class="keyword">static</span> symmetricDifference(a, b) &#123;</span><br><span class="line">    <span class="comment">// a∪b - a∩b</span></span><br><span class="line">    <span class="keyword">return</span> a.union(b).difference(a.intersection(b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个set的笛卡尔积，第一个是a的元素而第二个是b的所有可能有序对的其中一个元素</span></span><br><span class="line">  <span class="keyword">static</span> cartesianProduct(a, b) &#123;</span><br><span class="line">    <span class="keyword">const</span> cartesianProductSet = <span class="keyword">new</span> XSet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        cartesianProductSet.add([aValue, bValue]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cartesianProductSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个set的幂集</span></span><br><span class="line">  <span class="keyword">static</span> powerSet(a) &#123;</span><br><span class="line">    <span class="keyword">const</span> powerSet = <span class="keyword">new</span> XSet().add(<span class="keyword">new</span> XSet());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">set</span> of new XSet(powerSet)) &#123;</span><br><span class="line">        powerSet.add(<span class="keyword">new</span> XSet(<span class="keyword">set</span>).add(aValue));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return powerSet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WeakSet-类型"><a href="#WeakSet-类型" class="headerlink" title="WeakSet 类型"></a>WeakSet 类型</h3><p>在 ECMAScript6 中新添加的 WeakSet 是一种新的集合类型。Weakset 类型是 Set 类型的近亲，它的 API 是 Set 类型 API 的严格子集。“弱（weak）”这个名称描述了 JavaScript 的垃圾收集器如何处理弱映射中的值。</p>
<h4 id="基础-API-3"><a href="#基础-API-3" class="headerlink" title="基础 API"></a>基础 API</h4><p>用 new 关键字实例化一个空的 WeakSet 类型:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br></pre></td></tr></table></figure>

<p>Weakset 中的值只能是 Object 类型或者继承自 Object 类型 ー尝试使用非 Object 类型去设置值会抛出 TypeError。</p>
<p>如果希望在 WeakSet 初始化时就填充值，构造函数可以地接受一个可选包含有效值的对象。参数中的每个值将按照迭代的顺序插入到新创建的 WeakSet 中:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;,</span><br><span class="line">val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;,</span><br><span class="line">     <span class="comment">// 用嵌套数组实例化一个WeakSet</span></span><br><span class="line"><span class="keyword">const</span> ws1 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([val1, val2, val3]);</span><br><span class="line">alert(ws1.has(val1)); <span class="comment">// true</span></span><br><span class="line">alert(ws1.has(val2)); <span class="comment">// true</span></span><br><span class="line">alert(ws1.has(val3)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 实例化过程是一个要么全有要么全无的过程，一个错误的键名会抛出一个error并中止实例化过程</span></span><br><span class="line"><span class="keyword">const</span> ws2 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([val1, <span class="string">"BADVAL"</span>, val3]);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in WeakSet</span></span><br><span class="line"><span class="keyword">typeof</span> ws2;</span><br><span class="line"><span class="comment">// ReferenceError: ws2 is not defined</span></span><br><span class="line"><span class="comment">// 使用对象封装的原始类型仍然可以使用</span></span><br><span class="line"><span class="keyword">const</span> stringVal = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"val1"</span>);</span><br><span class="line"><span class="keyword">const</span> ws3 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([stringVal]);</span><br><span class="line">alert(ws3.has(stringVal)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>初始化后可以使用 add()方法添加值，使用 has()方法查询值，使用 delete()方法删除值:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> val1 = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  val2 = &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;;</span><br><span class="line">alert(ws.has(val1)); <span class="comment">// false</span></span><br><span class="line">ws.add(val1).add(val2);</span><br><span class="line">alert(ws.has(val1)); <span class="comment">// true</span></span><br><span class="line">alert(ws.has(val2)); <span class="comment">// true</span></span><br><span class="line">ws.delete(val1); <span class="comment">// 只删除这一个值</span></span><br><span class="line">alert(ws.has(val1)); <span class="comment">// false</span></span><br><span class="line">alert(ws.has(val2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>add()方法返回 WeakSet 实例，因此可以将多个 add 包括初始声明操作连接在一起，:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> val1 = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  val2 = &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  val3 = &#123; <span class="attr">id</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>().add(val1);</span><br><span class="line">ws.add(val2).add(val3);</span><br><span class="line">alert(ws.has(val1)); <span class="comment">// true</span></span><br><span class="line">alert(ws.has(val2)); <span class="comment">// true</span></span><br><span class="line">alert(ws.has(val3)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="弱键-1"><a href="#弱键-1" class="headerlink" title="弱键"></a>弱键</h4><p>“弱（weak）”源于 WeakSet 中的值是“弱持有（weakly held）”的，这意味着它们不被计算为正式的引用，也就不会阻止垃圾收集。</p>
<p>比如下面的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>在 add()中，一个新对象被初始化并用作 WeakSet 实例的一个值。因为没有对这个对象的其他引用，所以只要这一行执行完毕，该对象值就可以被垃圾收集器释放。当这种情况发生时，这个值将从 WeakSet 中消失并且为空。</p>
<p>下面是一个稍微不同的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> container = &#123;</span><br><span class="line">  val: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">ws.add(container.val);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeReference</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  container.val = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，container 对象维护对 WeakSet 实例中的值的引用，因此该对象不会被垃圾收集。但是，一旦调用 removeReference()，就会销毁对 val 对象的最后一个强引用，最终垃圾收集将清除该值。</p>
<h4 id="不可迭代的值"><a href="#不可迭代的值" class="headerlink" title="不可迭代的值"></a>不可迭代的值</h4><p>因为 WeakSet 中的值可以在任何时候被销毁，所以提供迭代这些值的方法是无意义的。也排除了一次销毁所有值的方法，所以 clear()不是 WeakSet API 的一部分。因为迭代是不可能的，所以从 WeakSet 实例中检索值也是不可能的（除非您有对值对象的引用）。即使代码可以访问 WeakSet 实例，也无法检查其内容。</p>
<p>WeakSet 实例将键限制仅为对象，也就是只能通过引用值对象从 WeakSet 中检索值。如果允许原始类型，WeakSet 将无法区分最初用于设置值的原始类型字符串和稍后初始化的相同原始类型字符串ーー这是一种不希望出现的行为。</p>
<h4 id="实用性-1"><a href="#实用性-1" class="headerlink" title="实用性"></a>实用性</h4><p>与 WeakMap 实例相比，WeakSet 实例的实用性更为有限，但它们对于标记对象仍然很有作用。</p>
<p>参考下面的例子，使用了一个常规的 Set:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> disabledElements = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="built_in">document</span>.querySelector(<span class="string">'#login'</span>);</span><br><span class="line"><span class="comment">// 添加进相关的set将节点标记为disabled</span></span><br><span class="line">disabledElements.add(loginButton);</span><br></pre></td></tr></table></figure>

<p>在这里，可以极快的通过查看 disabledElements 中元素来检查是否被禁用。但是，如果从 DOM 中删除该元素，该元素在 Set 中的存在将阻止垃圾回收器重新分配内存。</p>
<p>为了允许垃圾回收器重新分配元素的内存，可以使用 WeakSet 代替:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> disabledElements = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="built_in">document</span>.querySelector(<span class="string">'#login'</span>);</span><br><span class="line"><span class="comment">// 添加进相关的set将节点标记为disabled</span></span><br><span class="line">disabledElements.add(loginButton);</span><br></pre></td></tr></table></figure>

<p>现在，当从 DOM 中删除 WeakSet 中的任何元素时，垃圾回收器在进行垃圾收集时将忽略它在 WeakSet 中的引用。</p>
<h3 id="迭代和扩展操作符"><a href="#迭代和扩展操作符" class="headerlink" title="迭代和扩展操作符"></a>迭代和扩展操作符</h3><p>ECMAScript 6 引入了迭代器和扩展运算符，在集合引用类型上下文环境中特别有用。这些新工具允许简单的互操作性、克隆和修改集合类型。</p>
<blockquote>
<p>注意:Iterators and Generators 章节提供了更多关于迭代器如何使用的内容。</p>
</blockquote>
<p>如本章前文所示，四个原生集合引用类型定义了一个默认迭代器:</p>
<ul>
<li>Array</li>
<li>All typed arrays</li>
<li>Map</li>
<li>Set</li>
</ul>
<p>实际上，所有支持有序迭代的类型可以传递给 for..of 循环:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterableThings = [</span><br><span class="line">  <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">  (typedArr = <span class="built_in">Int16Array</span>.of(<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">  ]),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">9</span>, <span class="number">10</span>]),</span><br><span class="line">];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterableThing <span class="keyword">of</span> iterableThings) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> iterableThing) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// [5, 6]</span></span><br><span class="line"><span class="comment">// [7, 8]</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>所有上述类型都可以使用扩展操作。扩展运算符对迭代对象执行浅拷贝，使你可以用简洁的语法克隆整个对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1 === arr2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>期望一个可迭代对象参数的构造函数可以通过一个可迭代实例参数进行克隆:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(map1);</span><br><span class="line"><span class="built_in">console</span>.log(map1); <span class="comment">// Map &#123;1 =&gt; 2, 3 =&gt; 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map2); <span class="comment">// Map &#123;1 =&gt; 2, 3 =&gt; 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>还允许进行数组一部分的构造:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">0</span>, ...arr1, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>浅拷贝机制意味着只复制对象的引用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [&#123;&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line">arr1[<span class="number">0</span>].foo = ‘bar’;</span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">0</span>]); <span class="comment">// &#123; foo: ‘bar’ &#125;</span></span><br></pre></td></tr></table></figure>

<p>这些集合类型中的每一个都支持多种构造方法，比如 Array.of()和 Array.from()静态方法。当与扩展操作符结合时，这使得互操作性变得非常简单:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 把一个数组复制到一个类型化数组</span></span><br><span class="line"><span class="keyword">let</span> typedArr1 = <span class="built_in">Int16Array</span>.of(...arr1);</span><br><span class="line"><span class="keyword">let</span> typedArr2 = <span class="built_in">Int16Array</span>.from(arr1);</span><br><span class="line"><span class="built_in">console</span>.log(typedArr1); <span class="comment">// Int16Array [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(typedArr2); <span class="comment">// Int16Array [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 把一个数组复制到Map实例中</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(arr1.map(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, ‘val’ + x]));</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123;1 =&gt; ‘val 1’, 2 =&gt; ‘val 2’, 3 =&gt; ‘val 3’&#125;</span></span><br><span class="line"><span class="comment">// 把一个数组复制到set中</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(typedArr2);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 把一个Set实例复制回数组</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...set];</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="林景宜 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="林景宜 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag"># 翻译</a>
              <a href="/tags/JS/" rel="tag"># JS</a>
              <a href="/tags/JS%E9%AB%98%E7%A8%8B/" rel="tag"># JS高程</a>
              <a href="/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6/" rel="tag"># 红宝书</a>
              <a href="/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" rel="tag"># JavaScript高级程序设计</a>
              <a href="/tags/%E7%AC%AC4%E7%89%88/" rel="tag"># 第4版</a>
              <a href="/tags/Typed-Arrays/" rel="tag"># Typed Arrays</a>
              <a href="/tags/Map/" rel="tag"># Map</a>
              <a href="/tags/Set/" rel="tag"># Set</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/2da22a8d.html" rel="prev" title="JS高程第4版24章翻译：网络请求和远程资源">
      <i class="fa fa-chevron-left"></i> JS高程第4版24章翻译：网络请求和远程资源
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/ac8f4bae.html" rel="next" title="JS高程第4版新增章节翻译：迭代器和生成器">
      JS高程第4版新增章节翻译：迭代器和生成器 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型化数组"><span class="nav-number">1.</span> <span class="nav-text">类型化数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#历史"><span class="nav-number">1.1.</span> <span class="nav-text">历史</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#WebGL"><span class="nav-number">1.1.1.</span> <span class="nav-text">WebGL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类型化数组的出现"><span class="nav-number">1.1.2.</span> <span class="nav-text">类型化数组的出现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-ArrayBuffers"><span class="nav-number">1.2.</span> <span class="nav-text">使用 ArrayBuffers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DataView"><span class="nav-number">1.3.</span> <span class="nav-text">DataView</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ElementType"><span class="nav-number">1.3.1.</span> <span class="nav-text">ElementType</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#大端和小端"><span class="nav-number">1.3.2.</span> <span class="nav-text">大端和小端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#极端案例"><span class="nav-number">1.3.3.</span> <span class="nav-text">极端案例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型化数组-1"><span class="nav-number">1.4.</span> <span class="nav-text">类型化数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#类型化数组行为"><span class="nav-number">1.4.1.</span> <span class="nav-text">类型化数组行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#合并、复制和更改类型化数组"><span class="nav-number">1.4.2.</span> <span class="nav-text">合并、复制和更改类型化数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#向上和向下溢出"><span class="nav-number">1.4.3.</span> <span class="nav-text">向上和向下溢出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-类型"><span class="nav-number">2.</span> <span class="nav-text">Map 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础-API"><span class="nav-number">2.1.</span> <span class="nav-text">基础 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序和迭代"><span class="nav-number">2.2.</span> <span class="nav-text">顺序和迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在-Objects-和-Map-之间选择"><span class="nav-number">2.3.</span> <span class="nav-text">在 Objects 和 Map 之间选择</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内存文件"><span class="nav-number">2.3.1.</span> <span class="nav-text">内存文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#插入性能"><span class="nav-number">2.3.2.</span> <span class="nav-text">插入性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查找性能"><span class="nav-number">2.3.3.</span> <span class="nav-text">查找性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除性能"><span class="nav-number">2.3.4.</span> <span class="nav-text">删除性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakMap-类型"><span class="nav-number">3.</span> <span class="nav-text">WeakMap 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础-API-1"><span class="nav-number">3.1.</span> <span class="nav-text">基础 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弱键"><span class="nav-number">3.2.</span> <span class="nav-text">弱键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不可迭代的键"><span class="nav-number">3.3.</span> <span class="nav-text">不可迭代的键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实用性"><span class="nav-number">3.4.</span> <span class="nav-text">实用性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#私有变量"><span class="nav-number">3.4.1.</span> <span class="nav-text">私有变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DOM-节点元数据"><span class="nav-number">3.4.2.</span> <span class="nav-text">DOM 节点元数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-类型"><span class="nav-number">4.</span> <span class="nav-text">Set 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础-API-2"><span class="nav-number">4.1.</span> <span class="nav-text">基础 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序和迭代-1"><span class="nav-number">4.2.</span> <span class="nav-text">顺序和迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义形式化的-Set-操作"><span class="nav-number">4.3.</span> <span class="nav-text">定义形式化的 Set 操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakSet-类型"><span class="nav-number">5.</span> <span class="nav-text">WeakSet 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础-API-3"><span class="nav-number">5.1.</span> <span class="nav-text">基础 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弱键-1"><span class="nav-number">5.2.</span> <span class="nav-text">弱键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不可迭代的值"><span class="nav-number">5.3.</span> <span class="nav-text">不可迭代的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实用性-1"><span class="nav-number">5.4.</span> <span class="nav-text">实用性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代和扩展操作符"><span class="nav-number">6.</span> <span class="nav-text">迭代和扩展操作符</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="林景宜" src="/images/bangchui-logo.svg">
  <p class="site-author-name" itemprop="name">林景宜</p>
  <div class="site-description" itemprop="description">一个已婚的前端er</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/MagnetLin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;MagnetLin" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linjingyi321@qq.com" title="E-Mail → mailto:linjingyi321@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="external nofollow noopener noreferrer" target="_blank">吉ICP备17007191号-2 </a>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">林景宜</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'b82a041b865a317f34ae',
      clientSecret: 'c392fb3d75a89b073e3dfe301a85b6f981c8ea86',
      repo: 'MagnetLinComments',
      owner: 'MagnetLin',
      admin: ['MagnetLin'],
      id: '49907152f6618b8c8e3aa061494b1333',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
